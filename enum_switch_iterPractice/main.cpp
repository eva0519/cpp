#include <iostream>
#include <time.h>

using namespace std;

/*
	열거체 : 연속된 숫자에 이름을 부여할 수 있는 기능이다.
	abcf 열거체명 {} 의 형태로 구성된다.
	열거체명을 이용해서 열거체 타입의 변수를 선언도 가능하다.
	즉, 열거체 자체가 사용자정의 변수 타입이 될 수도 있다. 타입(bool,short,int,float,double,char과 같은것)
	열거체는 숫자에 이름을 붙여주는 기능이다.
*/
enum class NUM : unsigned int
{
	NUM_0, // 아무것도 부여하지 않을시 0부터 1씩 차례로 값이 부여된다. 마우스를 대면 값나옴
	NUM_1,
	NUM_2 = 0x00B0, // NUM_2 = 0x0010 중간에 값이 바껴도 해당 값부터 1씩더한다.
	NUM_3
};
// switch 문의 case 등에 상수를 부여할때 특별한 값 등에 사용하면 
// 코드 가독성이 좋아지고 코딩할때 까먹지않고 편하다.

#define NUM_4 4
// 앞에 #이 붙으면 전처리기로 컴파일 타임에 특정 값이 정해진다. 위와 같은 상수타입.
// 전처리기 이므로 ;는 붙이지 않는다. 오류난다.

//가위바위보용 열거체. 가위바위보를 숫자등으로 나타내지만
//이를 012로 알아보려면 번거롭기에 012를 가위바위보로 명명해주기에 이를 플래그라 하는것
enum SRP //시져스,락,페이퍼
{
	SRP_S = 1,
	SRP_R = 2,
	SRP_P = 3,
	SRP_END
};

int main() 
{
	/*
	switch문 : 분기문의 한 종류이다. if문이 조건을 체크하는 분기문이라면
	switch문은 값이 뭔지를 체크하는 분기문이다.
	형태 : switch(변수) {} 의 형태로 구성된다. 
	코드블럭 안에는 case break 구문이 들어가게 된다.
	case 상수: 의 형태로 처리가 되고 변수값이 무엇인지에 따라서
	case 뒤에 오는 상수를 비교하게 된다.
	*/
	int iNumber = 1;
	cout << "숫자를 입력하세요 : ";
	/*cin >> iNumber;*/

	switch (iNumber)
	{
	case int(NUM::NUM_1): // iNumber 값이 무엇인지에 따라서 실행되는 case 구문이 결정된다.
		cout << "입력한 숫자는 1입니다." << endl;
		break; // break 문을 만나게 되면 switch문을 빠져나가게 된다.
	case int(NUM::NUM_2):
		cout << "입력한 숫자는 2입니다." << endl;
		// 이처럼 break가 없을 경우 바로 아래에 있는 case 구문도 강제로 실행된다
		// 현재 NUM_2는 16진수로 176의 상수값을 할당해놓았다.
	case int(NUM::NUM_3):
		cout << "입력한 숫자는 3입니다." << endl;
		break;
	case NUM_4:
		cout << "입력한 숫자는 4입니다." << endl;
		break;
	default: // case로 지정되어 있지 않은 숫자가 들어올 경우 실행된다. 
		cout << "그 외의 숫자입니다." << endl; // if문의 else를 생각하면된다.
		break;
	}
	
	//추후 더 볼 필요 있음* enum class에 대해
	NUM Numv = NUM::NUM_2;
	cout << (int)Numv << endl;
	//기존의 enum은 모호한 정수형 타입이라 아래처럼 형변환을 해주지 않아도 int로
	//암시적 인정을하지만 최신 c++11의 경우 enum과 마찬가지로
	//enum class에 있는 값은 const 값이기에 변수가 아닌 상수값(고정된)이고 enum처럼 자동 int 변환을 해주지 않는다.
	//고로 정수형 변수로 쓰고싶으면 일일히 명시적변환 static_cast를 해줘야한다.
	//그리고 앞에 열거체명도 꼭 붙여줘야한다. 귀찮지만 그래도 enum class를 쓰자.
	//enum의 본래 의도는 enum class에 가깝고 그것이 프로그래밍하는데 있어 개발자가 더 명확한 값을 다룰 수 있다.
	Numv = (NUM)10;
	//명시적 형변환 이런 식

	NUM eNUM = (NUM) 10; 
	//열거체 타입의 변수를 선언했다.
	//열거체 타입의 변수는 무조건 4byte를 차지하게 된다. 32비트.
	//열거체를 이용해 선언한 변수는 값의 표현 범위가
	//열거체에 나열된 값들 안에서 선택해서 사용한다.
	//열거체에 없는 값을 넣으려고 하면 경고가 뜨지만 위처럼 타입캐스팅을 하면 빌드가 가능하다.
	/*NUM eNUM = NUM_3;*/  // 본래 이런식으로 사용한다. 게임이라면 클래스명 등을 넣어서
	// 직업별로 이름을 지어 열거해 switch의 case 문에 대입하는 방식이다.
	cout << int(eNUM) << endl;

	//대소문자를 바꿔 eNUM 등의 열거형 타입 변수를 선언해도
	//열거형에서는 enum과 


	//sizeof(타입 or 변수)를 하게되면 해당 타입 혹은 변수의 메모리 크기를 구해준다.
	cout << sizeof(eNUM) << endl;
	cout << sizeof(NUM) << endl;

	//typeid(타입 or 변수).name() 을 하게되면 typeid 안에 들어간 타입 혹은
	//변수의 타입을 문자열로 반환해준다.
	cout << typeid(eNUM).name() << endl;
	//abcf NUM 이라고 출력된다.


	//c# 등의 나중에 나온 언어들은 가비지컬렉션 등의 기능으로 자동으로 메모리를 관리해주지만
	//c c++ 등은 그러한 기능없이 프로그래머가 메모리 관리를 하면서 프로그래밍 해야한다.

	/*
	반복문 : 특정 작업을 반복해서 수행해주는 기능.
	종류 : for, while, do while 3종류가 존재한다.
	while(조건식) {} 형태로 구성된다.
	while문은 조건식을 체크해서 true일 경우 코드블럭 안의 코드가 동작되고
	다시 조건식을 체크한다. 조건식이 false가 되면 while문을 빠져나오게 된다.
	반복문 안에서 break을 만나게 되면 해당 반복문을 빠져나오게 된다.
	*/
	iNumber = 0;
	while (iNumber < 10) // true를 조건으로 넣어버리면 무한 루프가 되버린다.
	{
		cout << iNumber << endl;
		++iNumber;

		if (iNumber == 4)  //예외 처리
			break;
	}
	
	//가위바위보 게임 만들기

	//화면을 깨끗히 지워준다.
	system("cls"); 
	//도스 명령을 처리해주는 system 함수를 통해 cls 도스명령어로 콘솔창을 지운다.

	srand((unsigned int)time(0));
	
	int iPlayer, iAI;

	while (false)
	{
		cout << "1. 가위" << endl;
		cout << "2. 바위" << endl;
		cout << "3. 보" << endl;
		cout << "4. 종료" << endl;
		cout << "메뉴를 선택하세요 : " << endl;
		cin >> iPlayer;
		switch (iPlayer)
		{
		case SRP_S:
			cout << "플레이어 : 가위" << endl;
			break;
		case SRP_R:
			cout << "플레이어 : 바위" << endl;
			break;
		case SRP_P:
			cout << "플레이어 : 보" << endl;
			break;
		}

		if (iPlayer < SRP_S || iPlayer > SRP_END)
		{
			cout << "잘못된 값을 입력하였습니다." << endl;
			//일시정지 명령어
			system("pause");
			//continue : 반복문의 시작점으로 이동시켜주는 기능이다.
			continue;
		}

		else if (iPlayer == SRP_END)
			break;

		// 봇이 선택을 한다.
		iAI = rand() % 3 + SRP_S;

		switch (iAI)
		{
		case SRP_S:
			cout << "AI : 가위" << endl;
			break;
		case SRP_R:
			cout << "AI : 바위" << endl;
			break;
		case SRP_P:
			cout << "AI : 보" << endl;
			break;
		}

		short iWin = iPlayer - iAI;

		//if (iWin == 1 || iWin == -2)
		//	cout << "이겼습니다" << endl;
		//else if (iWin == 0)
		//	cout << "비겼습니다" << endl;
		//else
		//	cout << "졌습니다" << endl;

		//9개의 가지의 수가 있지만 수학적 규칙을 찾아내면 코드를 짧게 바꿀수 있다.
		//많은 알고리즘에서 두 변수 혹은 여러 변수를 합해서 특정 동일값이 
		//나오면 조건문으로 처리하는 식으로 코드를 줄일 수 있다. 
		//예를들어 a는 1씩 증가하고 b는 1씩 감소하는 알고리즘의 경우 합하면 결국 같은수다.
		//단순 숫자 확인 조건문이므로 switch 문으로도 나타낼 수 있다.

		switch (iWin)
		{
		case 1: // 해당 case 또한 상수이므로 enum 문으로 승리,패배,비김 식으로 또 잡아줄 수 있다.
		case -2:
			cout << "이겼습니다" << endl;
			break;
		case 0:
			cout << "비겼습니다" << endl;
			break;
		default:
			cout << "졌습니다" << endl;
			break;
		}
		system("pause");
		//콘솔 상에 가동되는 프로그램을 일시정지 하기 때문에 
		//계속하려면 아무키나 눌러주세요 문구가 뜬다.
	}

	//부분, 부품 단위로 보면서 프로그래밍해라
	//전체를 보면 어려움

	//상용 프로그램은 모두 무한루프 상태에 있다가 
	//예외처리(종료버튼 등)를 통해 빠져나가게 설계한다
	//윈도우 역시 마찬가지

	//for (int i = 0; i < 10; ++i)
	//{
	//	cout << rand() % 701 + 1000 << endl;
	//}

	/*
	for문 : 반복문의 한 종류이다
	형태 : for (초기값; 조건식; 증감값;) {} 의 형태로 구성이 된다
	조건식이 true이면 코드블럭의 코드가 동작된다.
	무한루프를 돌릴때는 for(;;) {} 을 해주면 무한으로 돌아간다.
	for문에서 초기값은 처음 for 문에 진입할때 딱 1번만 동작된다. 그 후에 조건식을
	체크하고 조건식이 true이면 코드블럭의 코드가 동작된 후에 증감값을 처리한다.
	그후 다시 조건을 체크하고 true면 동작되고 증감 -> 조건 -> 증감 -> 조건의
	순서로 처리가 되다 조건이 false이거나 break을 만나게 되면 for문을 빠져나가게 된다.
	*/

	//초기값 : i=0 조건식 : i < 10 증감값 : ++i
	/*
	먼저 for문에 진입하면서 초기값이 실행되므로 i를 초기화한다.
	그 후에 i<10을 체크해서 0일때는 true가 나오게 되어 i값을 출력한다.
	그 후에 증감을 처리하는데 ++을 하면 0에서 1이 되고 조건을 체크하게된다.
	1은 10보다 작으므로 true가 나오고 1출력해서 ++해서 2가 되고 조건 true
	2출력 3,4,5,6,7,8,9 까지는 조건이 true라서 9를 출력하고 ++이 되어 10이되고
	10<10을 하면 조건이 false가 되므로 반복문을 빠져나오게 된다.
	*/
	// ++i는 반복문 1회차가 끝난 뒤 진행되는걸 유의 1~9가 아닌 0~9가 나온다.
	//for (int i = 0; i < 10; ++i)
	//{
	//	cout << i << endl;
	//}

	//구구단 2단을 출력해보자
	//for (int i = 1; i < 10; ++i)
	//{
	//	cout << "2 X " << i << " = " << 2 * i << endl;
	//}

	//구구단을 출력하기
	//for (int i = 2; i < 10; ++i)
	//{
	//	cout << i << "단" << endl;
	//	for (int j = 1; j < 10; ++j)
	//	{
	//		cout << i << " X " << j << " = " << i * j << endl;
	//	}
	//}

	// 1 ~ 100 사이의 숫자중 짝수만 출력하는 for문을 작성해보자. (if없이)

	//for (int i = 2; i <= 100; i += 2)
	//{
	//	cout << i << endl;
	//}
	// 증감자에 i + 2를 하면 안된다.
	// i 에 증감된 값이 대입되어야 (return된다는 인식) 하기 때문에 i = i+2(i+=2)라고 해야한다.
	// 고로 반복문의 증감값이 i 에 값을 저절로 대입시켜준다고 생각하면 안된다.

	//3과 7의 공배수만 출력해보자
	//for (int i = 1; i <= 100; ++i)
	//{
	//	if (i % 3 == 0 && i % 7 == 0)
	//		cout << i << endl;
	//}

	//중첩 for문 : for문 안에 또다른 for문이 존재하는 형태이다. 
	//이지만 위에 수업중에 이미 만들어봄
	//구구단같은 것으로 배열을 이용해 2차원 배열을 만들때 좋다.

	//for (int i = 0; i < 10; ++i)
	//{
	//	for (int j = 0; j < 10; ++j)
	//	{
	//		cout << "i = " << i << ", j = " << j << endl;
	//	}
	//}

	//수업외 형변환 추가

	float number1 = 55.55f;
	cout << number1 << endl;
	int number2 = (int)number1;
	cout << number2 << endl;    // 55
	bool number3 = (bool)number1;
	cout << number3 << endl;    // 1
	//명시적 형변환

	//float number4 = 55.55;
	//cout << number4 << endl;
	//int number5 = number4;
	//cout << number5 << endl;    // 55
	//bool number6 = number4;
	//cout << number6 << endl;    // 1
	//묵시적 형변환

	//결과는 같음
	//*명시적 형변환의 경우 내부적으로 임시변수를 생성에 대입하는 방식으로 성능 저하를 일으킬 수 있다.
	//*묵시적 형변환의 경우 데이터 손실에 대한 경고가 발생한다.
	//묵시적 형변환의 경우 값의 본래 타입을 까먹거나 실수할 수 있으니 성능저하 가능성이 있더라도
	//명시적 형변환을 사용하는게 추후 이롭다.
	//이와 관련해서 생겨난 키워드가 explict로 묵시적 변환을 막아버리는 기능이다.




	/*
	숙제 : 
	1. 구구단을 2단부터 9단까지 출력하는 중첩for문을 만들어보자.
	2. 별을 아래의 형태로 출력되게 한다.
	*
	**
	***
	****
	*****

	3. 별을 아래의 형태로
	*****
	****
	***
	**
	*

	4. 별을 아래의 형태로
	   *
	  ***
	 *****
	*******

	*/

	//1번
	for(int i = 2; i < 10; ++i)
	{
		cout << i << "단" << endl;

		for(int j = 1; j < 10; ++j)
		{
			cout << i << " X " << j << " = " << i * j << endl;
		}
	}

	cout << endl;


	//2번
	for (int i = 0; i < 5; ++i)
	{
		for (int j = 0; j < i + 1; ++j)
		{
			cout << "*";
		}
		/*cout << '\n';*/
		cout << endl;
	}
	//endl 은 줄바꿈을 하고 flush 작업 (사용후 사용된 버퍼를 비우는 작업)
	//까지 진행해주기 때문에 4000ms 근사치의 시간이 걸린다.
	//속도를 빠르게 해주고 싶다면 '\n' 을 사용하자. 속도는 100배 정도 빠르다.

	cout << endl;


	//3번
	for (int i = 0; i < 5; ++i)
	{
		for (int j = 0; j < 5 - i; ++j)
		{
			cout << "*";
		}
		/*cout << '\n';*/
		cout << endl;
	}

	cout << endl;

	
	//4번
	//공백 : 3,2,1,0  별 : 1,3,5,7
	for (int i = 0; i < 4; ++i)
	{
		// 공백 출력을 위한 for문
		for (int j = 0; j < 3 - i; ++j)
		{
			cout << " ";
		}
		// 별 출력을 위한 for문
		for (int j = 0; j < i * 2 + 1; ++j)
		{
			cout << "*";
		}
		cout << endl;
	}
	//0부터 1씩 증가할때 홀수가 되려면 증감되는 변수에 
	//2를 곱하고 +1을 더하는 식은 많이 사용된다.


	//구구단 다른 형태로 만들기
	//2단 3단 4
	//5   6   7
	//8   9   10
	//3줄임을 명시. 콘솔에서 탭은 "\t" 이다.
	for (int i = 2; i < 11; i = i += 3)
	{
		for (int j = 1; j < 10; j++)
		{
			cout << i << " * " << j << " = " << i * j << '\t';
			cout << i + 1 << " * " << j << " = " << (i + 1) * j << '\t';
			cout << i + 2 << " * " << j << " = " << (i + 2) * j << endl;
		}
		cout << endl;
	}

	/* 다이아 만들기
	   *
	  ***
	 *****
	*******
	 *****
	  ***
	   *
	*/

	//공백 3,2,1,0,1,2,3   별 1,3,5,7,5,3,1   줄 7줄
	//중간에 정점을 찍고 +-가 바뀌므로 if문을 삽입해 정점 이후 식이 변경되게한다.
	//줄역할을 할 변수와 몇번째 줄에있는지 카운팅 해줄수 있는 변수를 만들어서
	//확장성도 관리한다.
	int iLine = 6;
	int iCount = 0;

	//카운트 같은 반복문 중간에 수를 캐치할 수 있는 스위치 같은
	//성격을 가진 변수를 선언해두면 둘수록 여러 변형을 줄 수 있다.
	//고로 안써도 일단 만들어놓고 다만들고 필요없으면 지우자. 
	//가지고 놀 수 있는 도구는 많을수록 좋다.

	for (int i = 0; i < iLine; ++i)
	{
		iCount = i;
		//다이아몬드 하단 5,6,7번째 줄에서 식이 바뀌어야하므로 0부터 하면 4,5,6이다
		//이 조건문이 일종의 식을 중간에 트는 스위치라고 보면 됨.
		if (i > iLine / 2) // 7/3 = 3  3 + 1 4  즉 i가 3보다 크면 실행되는 조건문
		{
			iCount = (iLine - 1) - i;    
			// i가 4일때 조건문으로 들어오고 iCount가 차례로 2 1 0이 되야 아래서 공백이 늘어나니
			// 이 알고리즘에서 가장 중요한 부분은 6 - i에서 6이다.
			// i의 최대수인 6에서 지속적으로 변하는 증감값 i를 빼줌으로써 값을 뒤집는 것
			// 핵심이기에 6을 변수인 iLine(줄수) 에서 -1을 빼는 증감식으로 바꾸면
			// iLine 변수를 홀수중 어느수로 바꾸든 다이아몬드의 크기를 조절할 수 있다.
			// 알고리즘을 짜는중 0,1,2가 아닌 수중 상수를 찾고
			// 그 수를 하드코딩없이 짜는 방법을 생각하는 편법도 있다.
			// 0은 0을 만들기쉽고 1은 동일수나 홀수 짝수를 만들수 있고
			// 2는 짝수구하기 만들기 등 써먹을 데가 많으나 
			// 그 외 알고리즘에서 써먹을 상수는 사람 대가리로는 쉽지 않으니 없앨 생각으로 대한다.
		}
		//공백 반복문. i회전에 따라 차례로 3,2,1,0,1,2,3개 찍혀야함
		for (int j = 0; j < iLine / 2 - iCount; ++j)
		{
			cout << " ";
		}
		//별 반복문. i회전에 따라 차례로 1,3,5,7,5,3,1개 찍혀야함
		//홀수증가니까 우선 *2 + 1 을 사용하자. 그리고 천천히 머리로 디버깅.
		//3까진 무리없고 5번째줄 즉 i가 4일땐 iCount를 바꾼다.
		for (int j = 0; j < iCount * 2 + 1; ++j)
		{
			cout << "*";
		}
		cout << endl;
	}
	// 이제 위의 iLine 변수만 바꿔도 다이아몬드 크기를 조절할 수 있다.

	/*
	do while 문 : 반복문의 한 종류이다.
	형태 : do {} while (조건식); 의 형태로 구성된다.
	while문은 처음 진입부터 조건식을 체크하지만 do while은 처음 한번은 무조건 동작이 되고
	그 후에 조건식을 체크해서 true일 경우 동작되는 반복문이다.
	*/
	int iNumber2 = 0;

	do
	{
		cout << iNumber2 << endl;
	} while (iNumber2 > 0);



	return 0;
}